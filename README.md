# Поиск регулярных выражений в области памяти

Программа для поиска регулярных выражение в области памяти. Как следствие поиск по тексту.
Суть работы программы: область памяти разбивается на равные части и подается каждому потоку своя часть памяти. В потоке и осуществляется поиск регулярного выражения.
Основа поиска состоит это "дерево" из регулярных выражений на это дерево подается по байтно память, проходя по дереву происходит поиск.

Поиск осуществляется при помощи 3 видов квантификаторов:
 -  <b>\*</b>  не одного символа или много символов
 -  <b>?</b>   не одного символа или один символ
 -  <b>.</b>   один символ <br>
 если нужно использовать квантификатора как простой символ, то квантификатор экранируется символом **/**

Так же есть ограничения по созданию регулярных выражений:
  1. Различные квантификаторе не могут следовать друг за другом
     - Пример: abc.? - не правильно
  1. Квантификаторы одного вида могут следовать друг за другом:
     - Пример: abc.. - правильно

<br>
!!! Важно !!! при поиске слов, кодировка в месте поиска и кодировка регулярных выражение должна быть одного вида!!!<br>
  Например: регулярные выражения = Unicode и тест где будет осуществляться поиск = Unicode 
<br>



## Сборка и запуск приложения
Собирается на Debina 12, следовательно на различных видах Linux на основе Debian должно(но не обязанно) собираться. <br>
Используемые компиляторы : 
  - С++ = g++ 12
  - C = gcc 12

Шаги для сборки:
1. зайти в папку с исходным кодом
1. `mkdir build`
1. `cd build/`
1. `make -j 2` <br>
После выше описанных шагов создаться 3 файла:

- find_regual_cli - программа для поиска регулярных выражений в тексте. Взглянув на исходник `main.cpp` можно понять как работает программа</br>
Пример ввода:<br> `./find_regual_cli poems.txt Пушкин Закинул*невод` <br>
где `./find_regual_cli` - программа выполняющая поиск.<br>
`poems.txt` - область памяти где осуществляется поиск. Считывает файл и ищет как в большой строке. <br>
`Пушкин Закинул*невод` - два регулярных выражения, разделяются пробелом<br>

- libfind_regual.so - динамическая библиотека, заголовочный файл для нее include/tree_search_engine.hpp <br>
Для поиска нужно использовать класс TreeSearchEngine, основные методы:
  >    Добавить регулярное выражение, если работает поиск, регулярное выражение не будет добавлено <br>
  >  <b>bool addRegularExpression(const std::string &regular);</b><br>
  >   @param regular регулярное выражение<br>
  >   @return true добавлено<br>
  >   @return false не добавлено   <br>
  

  сам поиск происходит вызовом метода ниже <br>
  >
  > @brief запустить поиск <br>
  >  <b>std::tuple<void*, size_t, std::string> start_search(void *memory, size_t size);</b> <br>
  > @param memory область памяти где производится поиск <br>
  > @param size размер области памяти где производится поиск<br>
  > @return std::tuple<void\*, size_t, std::string> возвращает <br>
  >      < void\* - <b> !не всегда показывает верно!</b> место первого вхождения регулярного выражения,<br>
  >        size_t -<b>!не всегда показывает верно!</b> порядковый номер символа где начинается регулярное выражение,<br>
  >        std::string - <b>!всегда показывает верно!</b> найденное регулярное выражение><br>
  >    если ничего не найдено то на выходе будет <b> <null, 0, ""> </b> <br> 

  после поиска или перед нужно вызывать метод для очистки внутреннего состояния
  >чистка поля ответов, атомиков. Необходимо осуществлять перед началом или после поиска<br>
  ><b>void clearSearch()</b>

- test_regular - запускается для проверки работы алгоритма, так же посмотрев исходный код можно понять как работает алгоритм.
  


